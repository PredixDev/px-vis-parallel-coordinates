<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-colors-design/colors.html" />
<link rel="import" href="../px-vis/px-vis-behavior-common.html" />
<link rel="import" href="../px-vis/px-vis-behavior-d3.html" />
<link rel="import" href="../px-vis/px-vis-behavior-chart.html"/>
<link rel="import" href="../px-vis/px-vis-svg-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-line.html"/>
<link rel="import" href="../px-vis/px-vis-multi-axis.html"/>
<link rel="import" href="../px-vis/px-vis-multi-scale.html"/>
<link rel="import" href="../px-vis/px-vis-gridlines.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />


<!--
PX Vis component that creates a parallel coordinates (aka parallel axes) chart.

##### Usage - Specifying your axes manually

    <px-vis-parallel-coordinates
        width="1300"
        height="500"
        chart-data="[[chartData]]"
        axes='["Axes_1","Axes_2","Axes_n"]'
        series-key="TimeStamp"
        match-ticks
        series-config='{
            "TTXD1_1":{
              "yAxisUnit": "Hz",
              "title": "name1"
            },
            "TTXD1_12":{
              "yAxisUnit": "F",
              "title": "stout"
            }
          }'
    ></px-vis-parallel-coordinates>

##### Usage - Auto-generating your axes from data

    <px-vis-parallel-coordinates
        width="1300"
        height="500"
        chart-data="[[chartData]]"
        skip-keys='{"UnitNumber":true,"DLN_MODE":true}'
        series-key="TimeStamp"
        generate-axes-from-data
        match-ticks
    ></px-vis-parallel-coordinates>


@element px-vis-parallel-coordinates
@blurb PX Vis component that creates a parallel coordinates (aka parallel axes) chart.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-vis-parallel-coordinates">
  <link rel="import" type="css" href="css/px-vis-parallel-coordinates.css"/>
  <template>
    <div id="wrapper" class="wrapper">
      <px-vis-multi-scale
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]"
        axes="[[axes]]"
        dimensions="[[dimensions]]"
        chart-data="[[chartData]]"
        complete-series-config="[[completeSeriesConfig]]"
        chart-extents="[[chartExtents]]"
        x="{{x}}"
        y="{{y}}"
        current-domain-x="{{currentDomainX}}"
        current-domain-y="{{currentDomainY}}">
      </px-vis-multi-scale>
      <px-vis-svg-canvas
        canvas-context="{{canvasContext}}"
        svg="{{svg}}"
        px-svg-elem="{{pxSvgElem}}"
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]">
      </px-vis-svg-canvas>
      <px-vis-line
        id="line"
        render-to-canvas
        gradient-line
        canvas-context="[[canvasContext]]"
        svg="[[svg]]"
        parallel-coordinates
        multi-path
        series-id="[[seriesKey]]"
        category-key="[[categoryKey]]"
        categories="[[categories]]"
        chart-data="[[chartData]]"
        complete-series-config="[[completeSeriesConfig]]"
        x="[[x]]"
        y="[[y]]"
        current-domain-x="[[currentDomainX]]"
        current-domain-y="[[currentDomainY]]"
        selected-domain="[[selectedDomain]]"
        muted-series="[[_combineMutes(mutedSeriesBrush,mutedSeriesDomain)]]"
        no-canvas-progressive-rendering="[[noCanvasProgressiveRendering]]">
      </px-vis-line>
      <px-vis-multi-axis
        svg="[[svg]]"
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]"
        title-location='[[titleLocation]]'
        x="[[x]]"
        y="[[y]]"
        current-domain-x="[[currentDomainX]]"
        current-domain-y="[[currentDomainY]]"
        complete-series-config="{{completeSeriesConfig}}"
        series-key="[[seriesKey]]"
        chart-data="[[chartData]]"
        dimensions="[[dimensions]]"
        axes="[[axes]]"
        muted-series="{{mutedSeriesBrush}}"
        redraw-series="true"
        redraw-elems="[[_lineRedrawFun()]]"
        stroke-width="2"
        match-ticks="[[matchTicks]]"
        grid-ticks="{{gridTicks}}"
        grid-axis="{{gridAxis}}"
        common-axis="[[commonAxis]]"
        outer-tick-size="6"
        truncation-length="[[truncationLength]]"
        displayed-values="{{displayedValues}}"
        append-unit-in-title>
      </px-vis-multi-axis>
      <template is="dom-if" if="[[matchTicks]]">
        <px-vis-gridlines
          svg="[[_calcGridSvg(svg,x,axes,currentDomainX)]]"
          tick-values="[[gridTicks]]"
          axis="[[gridAxis]]"
          margin="[[margin]]"
          length="[[_calcGridWidth(width,x,axes,currentDomainX)]]"
          orientation="left"
          current-domain="[[currentDomainY]]">
        </px-vis-gridlines>
      </template>
    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-parallel-coordinates',

    behaviors: [
      PxVisBehavior.sizing,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.canvas,
      PxVisBehaviorD3.axis,
      PxVisBehavior.dataset,
      PxVisBehavior.dimensions,
      PxVisBehavior.commonMethods,
      PxVisBehavior.chartExtents,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehaviorD3.axisConfig,
      PxVisBehavior.mutedSeries,
      PxVisBehaviorD3.dynamicRedraw,
      Polymer.IronResizableBehavior,
      PxVisBehavior.categories,
      PxVisBehavior.commonAxis,
      PxVisBehaviorD3.selectedTimeDomain,
      PxVisBehaviorChart.saveImage,
      PxVisBehavior.progressiveRendering,
      PxVisBehaviorChart.chartAutoResize,
      PxVisBehavior.truncating,
      commonColors
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * A dev set Object of which keys in the chart data should not be used as axes.
       *
       * `Required` if axes is not specified.
       *
       * ```
       *    {
       *        "Axes_to_skip_1":true,
       *        "Axes_to_skip_2":true
       *    }
       * ```
       */
      skipKeys: {
        type: Object,
        notify: true,
        value: function() { return {}; }
      },
      /**
       * A `Required` dev set string which defines which data key to use for the series lines
       *
       *  This depends on your data and could be *x*, *Timestamp*, ect.
       *
       */
      seriesKey: {
        type: String,
        notify: true
      },
      /**
       * A boolean to specify if the axis ticks should align (which affects their individual range). Default (false) is for each have their own ranges and tick marks may not align
       *
       */
      matchTicks: {
        type: Boolean,
        value: false
      },
      /**
       * An object which holds the series lines that have been muted based on the selected domain
       *
       * @private
       */
      mutedSeriesDomain: {
        type:Object,
        notify: true
      },
      /**
       * An object which holds the series lines that have been muted based on the axes brushes
       *
       * @private
       */
      mutedSeriesBrush: {
        type:Object,
        notify: true
      },
      /**
       * An object to hold which axes should be muted.
       *
       * *When adding keys to this, be sure to use Polymer set methods or notifyPath*
       *
       * ```
       *    {
       *        "Axes_to_skip_1":true,
       *        "Axes_to_skip_2":true
       *    }
       * ```
       */
      mutedAxes: {
        type: Object,
        notify: true,
        value: function() { return {}; }
      },
      /**
       * A boolean to specify if axes are developer set or should be generated from the chart data
       *
       */
      generateAxesFromData: {
        type: Boolean,
        value: false
      },
      /**
      * A configuration file to associate series order, name, type, and colors.
      *
      * Association of name, type, and seriesNumber should be developer set. Color and axis are optional.
      *
      *```
      *  {
      *     "seriesKey": {              //seriesKey is a unique identifier for the configuration
      *         "color": "line",        //color of the line for this axis
      *         "yAxisUnit": "Oranges"  //unit to be used for this axis.
      *     }
      *  }
      *```
      */
      seriesConfig: {
        type: Object,
        notify: true,
        value: function(){ return {} }
      },
      /**
       * Object representing the actual displayed titles for each axis
       */
      displayedValues: {
        type: Object
      }
    },

    observers: [
      '_generateChartExtents(dimensions,chartData,commonAxis)',
      '_generateSeriesConfig(dimensions,chartData, seriesConfig)',
      '_computeAxes(chartData.*,skipKeys.*)',
      '_computeDimensions(axes.*, mutedAxes.*)',
      // '_calcRenderTarget(chartData)',
      '_selectedDomain(selectedDomain.x)',
      '_calcTitleLocation(svg, height, width, dimensions, displayedValues.*)'
    ],

    listeners: {
     'iron-resize': '_onIronResize'
    },
    /**
     * At ready, set the margin and titleLocation objects
     *
     */
    _calcTitleLocation: function(svg, height, width, dimensions, displayedValues){

      this.debounce('calcTitleLocation', function() {

        var textWidth = 0,
            _this = this,
            keys = Object.keys(this.displayedValues),
            values = [];

        for(var i=0; i<keys.length; i++) {
          values.push(this.displayedValues[keys[i]]);
        }

        // append and remove the dimensions text so we can measure how long
        var labels = svg.selectAll('.dummyText')
          .data(values);
          labels.enter()
          .append("text")
          .attr('class',"dummyText")
          .attr('font-size', this.labelTypeSize + 'px')
          .attr('font-style','GE Inspira Sans')
          .text(function(d) {
            return d
          })
          .each(function(d,i) {
            var w = this.getComputedTextLength();
            textWidth = Math.max(w,textWidth);
            this.remove(); // remove them just after displaying them
          });

        // add a bit for a margin between text labels
        textWidth += 10;
        //do we have enough space for the largest text label?
        if(this.width / values.length < textWidth) {
          this.set('margin', { "top": 10, "right": 15, "left": 0, "bottom": textWidth});
          // vertical
          this.set('titleLocation',{
            "x":"3",
            "y":this.height - this.margin.bottom,
            "r":"-90",
            "anchor":"end"
          });
        } else {
          this.set('margin', { "top": 10, "right": 15, "left": 0, "bottom": (this.labelTypeSize + 8)});
          // horizontal
          this.set('titleLocation',{
            "x":"0",
            "y":this.height + 10 - this.margin.bottom,
            "r":"0",
            "anchor":"middle"
          });
          // angle
          // this.set('titleLocation',{
          //   "x":"0",
          //   "y":this.height - this.margin.bottom,
          //   "r":"-20",
          //   "anchor":"end"
          // });
        }
      }.bind(this), 5);
    },

    /**
     * FIXME: This should be called declaratively in renderToCanvas. But if we do this, first it triggers a draw rendering to svg and takes forever. Need to figure out where to put this and/or chain it so it works
     *
     */
    _calcRenderTarget: function(){
      this.set('renderToCanvas', this.chartData.length < 8000 );
    },
    /**
     * Method to compute the axes to use. It will use all the keys in the data except those specified in skipKeys
     *
     */
    _computeAxes: function(cD, sK){
      if(this._doesObjHaveValues(this.chartData)){
        var axes;
        // add series and category key to skipKeys
        this.skipKeys[this.seriesKey] = true;
        if(this.categoryKey){
          this.skipKeys[this.categoryKey] = true;
        }

        if(this.generateAxesFromData){
          if(typeof(this.axes) === 'undefined'){
            // TODO what if the first object doesnt have all the dimensions?
            axes = Object.keys(this.chartData[0]).filter(function(d) {
              return !this.skipKeys[d];
            }.bind(this));
          } else {
            var newAxes = Object.keys(this.chartData[0]).filter(function(d) {
              // what if they add data but dont want all axes, only the ones previously specified?
              return !this.skipKeys[d] && this.axes.indexOf(d) === -1;
            }.bind(this));
            axes = this.axes.concat(newAxes);
          }

          this.set('axes',axes);
        }
      }
    },

    /**
     * Method to compute the dimensions to use by using axes and mutedAxes.
     *
     */
    _computeDimensions: function(axes, muted){
      if(this._doesObjHaveValues(this.axes)){
        var dims;
        if(this._doesObjHaveValues(this.mutedAxes)){
          dims = this.axes.filter(function(d) {
            //only get dims that are not in dims, not supposed to be skiped, and not muted
            return !this.mutedAxes[d];
          }.bind(this));
        } else {
          dims = this.axes;
        }

        this.set('dimensions',dims);
      }
    },

    /**
     * Creates the series configuration file
     *
     */
      _generateSeriesConfig: function(dimensions, seriesConfig) {

      this.debounce('_generateSeriesConfig', function() {
        // TODO make work with multiple series
        var config = (this.seriesConfig) ? JSON.parse(JSON.stringify(this.seriesConfig)) : {};
        // add a seriesConfig with seriesKey as default
        config[this.seriesKey] = {
          "name": this.seriesKey,
          "x": dimensions,
          "y": dimensions
        };

        //FIXME Not sure this works....See color on 449
        if(!config[this.seriesKey]['color']) {
          config[this.seriesKey]['color'] = this._getColor(18);
        }

        // if categories are specified, use them
        if(typeof(this.categoryKey) !== 'undefined'){
          for(var i = 0; i < this.categories.length; i ++){
            config[this.categories[i]] = {
              "color": this._getColor(18 + i),
              "name": this.categories[i],
              "x": dimensions,
              "y": dimensions
            }
          }
        }

        this.set('completeSeriesConfig',config);
      }.bind(this), 0);
    },

    // * TODO These are in behavior chart. Should make it so we can import them from there */
    /**
     * Helper function to return the correct color for a particular index.
     **/
    _getColor: function(i){
      var l = this.seriesColorOrder.length,
          index = this._calcIndex(i,l);
      return this.dataVisColors[this.seriesColorOrder[ index ]];
    },
    /**
     * Helper function to calculate the index. When we run out of indcies, it loops back over valid indicies.
     **/
    _calcIndex: function(i,l){
      return i < l ? i : this._calcIndex(i - l,l);
    },
    /**
     * Creates the chartExtents for each dimension
     *
     */
    _generateChartExtents: function(dimensions){
      var ext = {
        "x": dimensions,
        "y": {}
      };

      // TODO Is there a smarter way of doing this?
      for(var i = 0; i < dimensions.length; i++){
        ext.y[dimensions[i]] = d3.extent(this.chartData, function(d) {
          return Number(d[dimensions[i]]);
        });
      }

      // TODO dev set common extents?
      // if we want a common axis, find overall extents
      if(this.commonAxis){
        var maxMin = d3.extent(d3.merge(d3.values(ext.y)));
        for(var i = 0; i < dimensions.length; i++){
          // set each axis extent to max & min
          // TODO this is not the most efficient strategy, but certainly is the easiest, especially to keep it dynamic. Better would be to use only a single scale instead of calculating a scale multiple times.
          ext.y[dimensions[i]] = maxMin;
        }
      }

      this.set('chartExtents',ext);
    },
    /**
     * Adds data to a muted series based on the selected domain
     *
     */
    _selectedDomain: function(sd){
      this.debounce('selected_domain',function(){
        var muted = {};
        for(var i = 0; i < this.chartData.length; i++){
          if(this.chartData[i][this.seriesKey] < sd[0] || this.chartData[i][this.seriesKey] > sd[1]){
            muted[this.chartData[i][this.seriesKey]] = true;
          }
        }
        this.set('mutedSeriesDomain',muted);
      },200);
    },
    /**
     * Takes the muted series from the axis brush and the selected domain and returns a merged copy of them
     *
     */
    _combineMutes: function(m1,m2){
      var muted = {};
      // for these, we assume that "false" items will just have been removed
      for(var k in m1){
        muted[k] = m1[k];
      }
      for(var k in m2){
        muted[k] = m2[k];
      }
      return muted;
    },

    /**
     * An array of the line elements.
     *
     */
    _lineRedrawFun: function(){
      return [this.$.line]
    },
    _onIronResize: function() {
      this.debounce('ironresize', function() {
         if(!this.preventResize) {
          wrapperRect = this.$.wrapper.getBoundingClientRect();

          this.set('width', wrapperRect.width);
          this.set('height', wrapperRect.height);
         }
      },100);
    },
    /**
     * Returns the width for the gridlines
     *
     */
    _calcGridWidth: function(w,x,axes){
      // overall width minus the inset for the axes
      return w - x(axes[0]) * 2;
    },
    /**
     * Retruns a g elem for the grid to draw to
     *
     */
    _calcGridSvg: function(svg,x,axes){

      // create a g and move it so it lines up with the first axis
      var currentG = svg.select('.grid');

      if(!currentG.node()) {

      return svg.append('g')
        .attr("class", "grid")
        .attr("transform", "translate(" + x(axes[0]) + ",0)");
      }
      else {
        return currentG.attr("transform", "translate(" + x(axes[0]) + ",0)");
      }
    },
    /**
     * Imperatively mute an axis or group of axes.
     *
     * This function both addes the axes to the mutedAxes list and fires a notifyPath
     *
     * Can pass a single axis id or an array of axes ids
     */
     addToMutedAxes: function(a) {
       this._changeMutedAxes(a,true);
     },
     /**
      * Imperatively mute an axis or group of axes.
      *
      * This function both addes the axes to the mutedAxes list and fires a notifyPath
      *
      * Can pass a single axis id or an array of axes ids
      */
      removeFromMutedAxes: function(a) {
        this._changeMutedAxes(a,false);
      },
     /**
      * Helper function to imperatively mute/unmute an axis or group of axes.
      *
      */
     _changeMutedAxes: function(a,bool) {
       if(typeof(a) === 'string'){
         this.set('mutedAxes.' + a, bool);
       } else if(Array.isArray(a)){
         for(var i = 0; i < a.length; i++) {
           this.mutedAxes[ a[i] ] = bool;
         }
         this.notifyPath('mutedAxes.' + a[0]);
       } else {
         console.error("Cannot add/remove axis. Improper axis type")
       }
     }
  });
</script>
