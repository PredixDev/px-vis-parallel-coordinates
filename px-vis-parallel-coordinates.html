<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-colors-design/colors.html" />
<link rel="import" href="../px-vis/px-vis-behavior-common.html" />
<link rel="import" href="../px-vis/px-vis-behavior-d3.html" />
<link rel="import" href="../px-vis/px-vis-behavior-chart.html"/>
<link rel="import" href="../px-vis/px-vis-svg-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-line.html"/>
<link rel="import" href="../px-vis/px-vis-multi-axis.html"/>
<link rel="import" href="../px-vis/px-vis-multi-scale.html"/>
<link rel="import" href="../px-vis/px-vis-gridlines.html"/>
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html" />


<!--
PX Vis component that creates a parallel coordinates (aka parallel axes) chart.

##### Usage

    <px-vis-parallel-coordinates
        width="1300"
        height="500"
        chart-data="[[chartData]]"
        skip-keys='{"TimeStamp":true}'
        series-key="TimeStamp"
    ></px-vis-parallel-coordinates>

@element px-vis-parallel-coordinates
@blurb PX Vis component that creates a parallel coordinates (aka parallel axes) chart.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-vis-parallel-coordinates">
  <link rel="import" type="css" href="css/px-vis-parallel-coordinates.css"/>
  <template>
    <div id="wrapper" class="wrapper">
      <px-vis-multi-scale
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]"
        axes="[[axes]]"
        dimensions="[[dimensions]]"
        chart-data="[[chartData]]"
        complete-series-config="[[completeSeriesConfig]]"
        chart-extents="[[chartExtents]]"
        x="{{x}}"
        y="{{y}}"
        current-domain-x="{{currentDomainX}}"
        current-domain-y="{{currentDomainY}}">
      </px-vis-multi-scale>
      <px-vis-svg-canvas
        canvas-context="{{canvasContext}}"
        svg="{{svg}}"
        px-svg-elem="{{pxSvgElem}}"
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]">
      </px-vis-svg-canvas>
      <px-vis-line
        id="line"
        render-to-canvas
        gradient-line
        canvas-context="[[canvasContext]]"
        svg="[[svg]]"
        parallel-coordinates
        multi-path
        series-id="[[seriesKey]]"
        category-key="[[categoryKey]]"
        categories="[[categories]]"
        chart-data="[[chartData]]"
        complete-series-config="[[completeSeriesConfig]]"
        x="[[x]]"
        y="[[y]]"
        current-domain-x="[[currentDomainX]]"
        current-domain-y="[[currentDomainY]]"
        selected-domain="[[selectedDomain]]"
        muted-series="[[_combineMutes(mutedSeriesBrush,mutedSeriesDomain)]]"
        no-canvas-progressive-rendering="[[noCanvasProgressiveRendering]]">
      </px-vis-line>
      <px-vis-multi-axis
        svg="[[svg]]"
        width="[[width]]"
        height="[[height]]"
        margin="[[margin]]"
        title-location='[[titleLocation]]'
        x="[[x]]"
        y="[[y]]"
        current-domain-x="[[currentDomainX]]"
        current-domain-y="[[currentDomainY]]"
        complete-series-config="{{completeSeriesConfig}}"
        series-key="[[seriesKey]]"
        chart-data="[[chartData]]"
        dimensions="[[dimensions]]"
        axes="[[axes]]"
        muted-series="{{mutedSeriesBrush}}"
        redraw-series="true"
        redraw-elems="[[_lineRedrawFun()]]"
        stroke-width="2"
        match-ticks="[[matchTicks]]"
        grid-ticks="{{gridTicks}}"
        grid-axis="{{gridAxis}}"
        common-axis="[[commonAxis]]"
        outer-tick-size="6">
      </px-vis-multi-axis>
      <template is="dom-if" if="[[matchTicks]]">
        <px-vis-gridlines
          svg="[[_calcGridSvg(svg,x,dimensions,currentDomainX)]]"
          tick-values="[[gridTicks]]"
          axis="[[gridAxis]]"
          margin="[[margin]]"
          length="[[_calcGridWidth(width,x,dimensions,currentDomainX)]]"
          orientation="left"
          current-domain="[[currentDomainY]]">
        </px-vis-gridlines>
      </template>
    </div>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-parallel-coordinates',

    behaviors: [
      PxVisBehavior.sizing,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.canvas,
      PxVisBehaviorD3.axis,
      PxVisBehavior.dataset,
      PxVisBehavior.dimensions,
      PxVisBehavior.commonMethods,
      PxVisBehavior.chartExtents,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehaviorD3.axisConfig,
      PxVisBehavior.mutedSeries,
      PxVisBehaviorD3.dynamicRedraw,
      Polymer.IronResizableBehavior,
      PxVisBehavior.categories,
      PxVisBehavior.commonAxis,
      PxVisBehaviorD3.selectedTimeDomain,
      PxVisBehaviorChart.saveImage,
      PxVisBehavior.progressiveRendering,
      PxVisBehaviorChart.chartAutoResize,
      commonColors
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * A dev set array of which keys in the chart data are not dimension axes. At a minimum, it must include the series-key. Required if axes is not specified.
       *
       */
      skipKeys: {
        type: Object,
        notify: true,
        value: function() { return {}; }
      },
      /**
       * A required dev set string which defines which data key to use for the series lines
       *
       */
      seriesKey: {
        type: String,
        notify: true
      },
      /**
       * A boolean to specify if the axis ticks should align or each have their own ranges
       *
       */
      matchTicks: {
        type: Boolean,
        value: false
      },
      /**
       * An object to hold which series lines should be muted based on the selected domain
       *
       */
      mutedSeriesDomain: {
        type:Object,
        notify: true
      },
      /**
       * An object to hold which series lines should be muted based on the selected brushes
       *
       */
      mutedSeriesBrush: {
        type:Object,
        notify: true
      },
      /**
       * An object to hold which axes should be muted
       *
       */
      mutedAxes: {
        type: Object,
        notify: true,
        value: function() { return {}; }
      },
      /**
       * A boolean to specify if axes are developer set or should be generated from the chart data
       *
       */
      generateAxesFromData: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_generateChartExtents(dimensions,chartData,commonAxis)',
      '_generateSeriesConfig(dimensions,chartData)',
      '_computeAxes(chartData.*,skipKeys.*)',
      '_computeDimensions(axes.*, mutedAxes.*)',
      // '_calcRenderTarget(chartData)',
      '_selectedDomain(selectedDomain.x)',
      '_calcTitleLocation(svg,dimensions, height, width)'
    ],

    listeners: {
     'iron-resize': '_onIronResize'
    },

    /**
     * At ready, set the margin and titleLocation objects
     *
     */
    _calcTitleLocation: function(svg,dim){

      this.debounce('calcTitleLocation', function() {

        var textWidth = 0,
            _this = this;

        // append and remove the dimensions text so we can measure how long
        var labels = svg.selectAll('.dummyText')
          .data(dim);
          labels.enter()
          .append("text")
          .attr('class',"dummyText")
          .attr('font-size', this.labelTypeSize + 'px')
          .attr('font-style','GE Inspira Sans')
          .text(function(d) { return d})
          .each(function(d,i) {
            var w = this.getComputedTextLength();
            textWidth = Math.max(w,textWidth);
            this.remove(); // remove them just after displaying them
          });

        // add a bit for a margin between text labels
        textWidth += 10;
        //do we have enough space for the largest text label?
        if(this.width / dim.length < textWidth) {
          this.set('margin', { "top": 10, "right": 15, "left": 0, "bottom": textWidth});
          // vertical
          this.set('titleLocation',{
            "x":"3",
            "y":this.height - this.margin.bottom,
            "r":"-90",
            "anchor":"end"
          });
        } else {
          this.set('margin', { "top": 10, "right": 15, "left": 0, "bottom": (this.labelTypeSize + 8)});
          // horizontal
          this.set('titleLocation',{
            "x":"0",
            "y":this.height + 10 - this.margin.bottom,
            "r":"0",
            "anchor":"middle"
          });
          // angle
          // this.set('titleLocation',{
          //   "x":"0",
          //   "y":this.height - this.margin.bottom,
          //   "r":"-20",
          //   "anchor":"end"
          // });
        }
      }.bind(this), 1);
    },

    /**
     * FIXME: This should be called declaratively in renderToCanvas. But if we do this, first it triggers a draw rendering to svg and takes forever. Need to figure out where to put this and/or chain it so it works
     *
     */
    _calcRenderTarget: function(){
      this.set('renderToCanvas', this.chartData.length < 8000 );
    },
    /**
     * Method to compute the axes to use. It will use all the keys in the data except those specified in skipKeys
     *
     */
    _computeAxes: function(cD, sK){
      if(this._doesObjHaveValues(this.chartData)){
        var axes;
        // add series and category key to skipKeys
        this.skipKeys[this.seriesKey] = true;
        if(this.categoryKey){
          this.skipKeys[this.categoryKey] = true;
        }

        if(this.generateAxesFromData){
          if(typeof(this.axes) === 'undefined'){
            // TODO what if the first object doesnt have all the dimensions?
            axes = Object.keys(this.chartData[0]).filter(function(d) {
              return !this.skipKeys[d];
            }.bind(this));
          } else {
            var newAxes = Object.keys(this.chartData[0]).filter(function(d) {
              // what if they add data but dont want all axes, only the ones previously specified?
              return !this.skipKeys[d] && this.axes.indexOf(d) === -1;
            }.bind(this));
            axes = this.axes.concat(newAxes);
          }

          this.set('axes',axes);
        }
      }
    },

    /**
     * Method to compute the dimensions to use by using axes and mutedAxes.
     *
     */
    _computeDimensions: function(axes, muted){
      if(this._doesObjHaveValues(this.axes)){
        var dims;
        if(this._doesObjHaveValues(this.mutedAxes)){
          dims = this.axes.filter(function(d) {
            //only get dims that are not in dims, not supposed to be skiped, and not muted
            return !this.mutedAxes[d];
          }.bind(this));
        } else {
          dims = this.axes;
        }

        this.set('dimensions',dims);
      }
    },

    /**
     * Creates the series configuration file
     *
     */
      _generateSeriesConfig: function(dimensions){
      // TODO make work with multiple series
      var config = {};
      // add a seriesConfig with seriesKey as default
      config[this.seriesKey] = {
        "color": this._getColor(18),
        "name": this.seriesKey,
        "x": dimensions,
        "y": dimensions
      }
      // if categories are specified, use them
      if(typeof(this.categoryKey) !== 'undefined'){
        for(var i = 0; i < this.categories.length; i ++){
          config[this.categories[i]] = {
            "color": this._getColor(18 + i),
            "name": this.categories[i],
            "x": dimensions,
            "y": dimensions
          }
        }
      }

      this.set('completeSeriesConfig',config);
    },

    // * TODO These are in behavior chart. Should make it so we can import them from there */
    /**
     * Helper function to return the correct color for a particular index.
     **/
    _getColor: function(i){
      var l = this.seriesColorOrder.length,
          index = this._calcIndex(i,l);
      return this.dataVisColors[this.seriesColorOrder[ index ]];
    },
    /**
     * Helper function to calculate the index. When we run out of indcies, it loops back over valid indicies.
     **/
    _calcIndex: function(i,l){
      return i < l ? i : this._calcIndex(i - l,l);
    },
    /**
     * Creates the chartExtents for each dimension
     *
     */
    _generateChartExtents: function(dimensions){
      var ext = {
        "x": dimensions,
        "y": {}
      };

      // TODO Is there a smarter way of doing this?
      for(var i = 0; i < dimensions.length; i++){
        ext.y[dimensions[i]] = d3.extent(this.chartData, function(d) {
          return Number(d[dimensions[i]]);
        });
      }

      // TODO dev set common extents?
      // if we want a common axis, find overall extents
      if(this.commonAxis){
        var maxMin = d3.extent(d3.merge(d3.values(ext.y)));
        for(var i = 0; i < dimensions.length; i++){
          // set each axis extent to max & min
          // TODO this is not the most efficient strategy, but certainly is the easiest, especially to keep it dynamic. Better would be to use only a single scale instead of calculating a scale multiple times.
          ext.y[dimensions[i]] = maxMin;
        }
      }

      this.set('chartExtents',ext);
    },
    /**
     * Adds data to a muted series based on the selected domain
     *
     */
    _selectedDomain: function(sd){
      this.debounce('selected_domain',function(){
        var muted = {};
        for(var i = 0; i < this.chartData.length; i++){
          if(this.chartData[i][this.seriesKey] < sd[0] || this.chartData[i][this.seriesKey] > sd[1]){
            muted[this.chartData[i][this.seriesKey]] = true;
          }
        }
        this.set('mutedSeriesDomain',muted);
      },200);
    },
    /**
     * Takes the muted series from the axis brush and the selected domain and returns a merged copy of them
     *
     */
    _combineMutes: function(m1,m2){
      var muted = {};
      // for these, we assume that "false" items will just have been removed
      for(var k in m1){
        muted[k] = m1[k];
      }
      for(var k in m2){
        muted[k] = m2[k];
      }
      return muted;
    },

    /**
     * An array of the line elements.
     *
     */
    _lineRedrawFun: function(){
      return [this.$.line]
    },
    _onIronResize: function() {
      this.debounce('ironresize', function() {
         if(!this.preventResize) {
          wrapperRect = this.$.wrapper.getBoundingClientRect();

          this.set('width', wrapperRect.width);
          this.set('height', wrapperRect.height);
         }
      },100);
    },
    /**
     * Returns the width for the gridlines
     *
     */
    _calcGridWidth: function(w,x,dim){
      // overall width minus the inset for the axes
      return w - x(dim[0]) * 2;
    },
    /**
     * Retruns a g elem for the grid to draw to
     *
     */
    _calcGridSvg: function(svg,x,dim){
      // create a g and move it so it lines up with the first axis
      var g = svg.append('g')
        .attr("class", "grid")
        .attr("transform", "translate(" + x(dim[0]) + ",0)");
      return g;
    }
  });
</script>
