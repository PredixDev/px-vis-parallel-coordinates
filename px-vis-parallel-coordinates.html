<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-colors-design/colors.html" />
<link rel="import" href="../px-vis/px-vis-behavior-d3.html" />
<link rel="import" href="../px-vis/px-vis-svg-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-line.html"/>
<link rel="import" href="../px-vis/px-vis-multi-axis.html"/>
<link rel="import" href="../px-vis/px-vis-multi-scale.html"/>
<link rel="import" href="../px-vis/px-vis-gridlines.html"/>


<!--
PX Vis component that creates a parallel coordinates (aka parallel axes) chart.

##### Usage

    <px-vis-parallel-coordinates
        width="1300"
        height="500"
        chart-data="[[chartData]]"
        skip-keys='{"TimeStamp":true}'
        series-key="TimeStamp"
    ></px-vis-parallel-coordinates>

@element px-vis-parallel-coordinates
@blurb PX Vis component that creates a parallel coordinates (aka parallel axes) chart.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-vis-parallel-coordinates">
  <link rel="import" type="css" href="css/px-vis-parallel-coordinates.css"/>
  <template>
    <px-vis-multi-scale
      x-axis-type="ordinal"
      y-axis-type="linear"
      parallel-coordinates
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      dimensions="[[dimensions]]"
      chart-data="[[chartData]]"
      complete-series-config="[[completeSeriesConfig]]"
      chart-extents="[[chartExtents]]"
      x="{{x}}"
      y="{{y}}"
      current-domain-x="{{currentDomainX}}"
      current-domain-y="{{currentDomainY}}">
    </px-vis-multi-scale>
    <px-vis-svg-canvas
      canvas-context="{{canvasContext}}"
      svg="{{svg}}"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]">
    </px-vis-svg-canvas>
    <px-vis-line
      id="line"
      render-to-canvas
      gradient-line
      canvas-context="[[canvasContext]]"
      svg="[[svg]]"
      parallel-coordinates
      multi-path
      series-id="[[seriesKey]]"
      chart-data="[[chartData]]"
      complete-series-config="[[completeSeriesConfig]]"
      x="[[x]]"
      y="[[y]]"
      current-domain-x="[[currentDomainX]]"
      current-domain-y="[[currentDomainY]]"
      muted-series="[[mutedSeries]]">
    </px-vis-line>
    <px-vis-multi-axis
      svg="[[svg]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      title-location='[[titleLocation]]'
      x="[[x]]"
      y="[[y]]"
      current-domain-x="[[currentDomainX]]"
      current-domain-y="[[currentDomainY]]"
      complete-series-config="{{completeSeriesConfig}}"
      series-key="[[seriesKey]]"
      chart-data="[[chartData]]"
      dimensions="[[dimensions]]"
      muted-series="{{mutedSeries}}"
      redraw-series="true"
      redraw-elems="[[_lineRedrawFun()]]"
      stroke-width="2"
      match-ticks
      grid-ticks="{{gridTicks}}"
      outer-tick-size="6">
    </px-vis-multi-axis>
    <px-vis-gridlines
      svg="[[svg]]"
      tick-values="[[gridTicks]]"
      axis="[[_calcGridAxis(dimensions,y)]]"
      margin="[[margin]]"
      length="[[width]]"
      orientation="left"
      current-domain="[[currentDomainY]]">
    </px-vis-gridlines>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-parallel-coordinates',

    behaviors: [
      PxVisBehavior.sizing,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.canvas,
      PxVisBehaviorD3.axes,
      PxVisBehaviorD3.axis,
      PxVisBehavior.dataset,
      PxVisBehavior.dimensions,
      PxVisBehavior.commonMethods,
      PxVisBehavior.chartExtents,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehaviorD3.axisConfig,
      PxVisBehavior.mutedSeries,
      PxVisBehaviorD3.dynamicRedraw,
      commonColors
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * An optional dev set array to specify which dimensions to plot
       *
       */
      axes: {
        type: Array,
        notify: true,
        value: function(){ return []; } //must!!!! have default value
      },
      /**
       * A dev set array of which keys in the chart data are not dimension axes. At a minimum, it must include the series-key. Required if axes is not specified.
       *
       */
      skipKeys: {
        type: Object,
        notify: true,
        value: function() { return {}; }
      },
      /**
       * A required dev set string which defines which data key to use for the series lines
       *
       */
      seriesKey: {
        type: String,
        notify: true
      },
      /**
       * A computed array of dimensions which the chart uses. If axes are specified, they are used for the dimensions. If not, it will use all the keys in the data except those specified in skipKeys
       *
       */
      dimensions: {
        type: Array,
        notify: true,
        computed: 'computeDimensions(chartData.*, axes, skipKeys.*)'
      },
      /**
       * A dev set array of objects defining which data keys should receive the same color.
       *
       */
      colorGroups: {
        type: Array,
        notify: true
      }
    },

    observers: [
      '_generateChartExtents(dimensions,chartData)',
      '_generateSeriesConfig(dimensions,chartData)',
      '_calcRenderTarget(chartData)'
    ],
    /**
     * At ready, set the margin and titleLocation objects
     *
     */
    ready:function(){
      console.time('draw');
      this.set('margin', { "top": 10, "right": 15, "left": 30, "bottom": 50});
      this.set('titleLocation',{
        "x":"0",
        "y":this.height - this.margin.bottom,
        "r":"-20",
        "anchor":"end"
      });
    },

    /**
     * FIXME: This should be called declaratively in renderToCanvas. But if we do this, first it triggers a draw rendering to svg and takes forever. Need to figure out where to put this and/or chain it so it works
     *
     */
    _calcRenderTarget: function(){
      this.set('renderToCanvas', this.chartData.length < 8000 );
    },
    /**
     * Method to compute the dimensions to use. If axes are specified, they are used for the dimensions. If not, it will use all the keys in the data except those specified in skipKeys
     *
     */
    computeDimensions: function(cD, axes, sK){
      if(this._doesObjHaveValues(this.chartData)){
        // if the dev specified which axes to use, set them as dimensions
        if(axes.length > 0) {
          return axes;
        }
        // else get them from the data.
        // TODO what if the first object doesnt have all the dimensions?
        return Object.keys(this.chartData[0]).filter(function(d) {
          return typeof(this.skipKeys[d]) === 'undefined'
        }.bind(this));
      }
    },

    /**
     * Creates the series configuration file
     *
     */
      _generateSeriesConfig: function(dimensions){
      // TODO make work with multiple series
      var config = {};
      config[this.seriesKey] = {
        "color": this._getColor(18),
        "name": 'All',
        "x": dimensions,
        "y": dimensions
      }

      this.set('completeSeriesConfig',config);
    },

    // * TODO These are in behavior chart. Should make it so we can import them from there */
    /**
     * Helper function to return the correct color for a particular index.
     **/
    _getColor: function(i){
      var l = this.seriesColorOrder.length,
          index = this._calcIndex(i,l);
      return this.dataVisColors[this.seriesColorOrder[ index ]];
    },
    /**
     * Helper function to calculate the index. When we run out of indcies, it loops back over valid indicies.
     **/
    _calcIndex: function(i,l){
      return i < l ? i : this._calcIndex(i - l,l);
    },
    /**
     * Creates the chartExtents for each dimension
     *
     */
    _generateChartExtents: function(dimensions){
      var ext = {
        "x": dimensions,
        "y": {}
      };

      // TODO Is there a smarter way of doing this?
      for(var i = 0; i < dimensions.length; i++){
        ext.y[dimensions[i]] = d3.extent(this.chartData, function(d) {
          return Number(d[dimensions[i]]);
        });
      }

      // TODO we will need to support a common axis:
      /*
        if(common axis){
          if(dev set extents){
            use em!
          } else {
            cycle through our found extents
            pick out the largest min and max
          }
        }
      */
      this.set('chartExtents',ext);
    },

    _calcGridAxis: function(dim,y){
      return y[dim[0]];
    },

    /**
     * An array of the line elements.
     *
     */
    _lineRedrawFun: function(){
      return [this.$.line]
    }
  });
</script>
