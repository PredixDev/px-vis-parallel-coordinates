<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-colors-design/colors.html" />
<link rel="import" href="../px-vis/px-vis-behavior-d3.html" />
<link rel="import" href="../px-vis/px-vis-svg-canvas.html"/>
<link rel="import" href="../px-vis/px-vis-line.html"/>
<link rel="import" href="../px-vis/px-vis-multi-axis.html"/>
<link rel="import" href="../px-vis/px-vis-multi-scale.html"/>
<link rel="import" href="../px-vis/px-vis-gridlines.html"/>


<!--
PX Vis component that creates a parallel coordinates (aka parallel axes) chart.

##### Usage

    <px-vis-parallel-coordinates
        width="1300"
        height="500"
        chart-data="[[chartData]]"
        skip-keys='{"TimeStamp":true}'
        series-key="TimeStamp"
    ></px-vis-parallel-coordinates>

@element px-vis-parallel-coordinates
@blurb PX Vis component that creates a parallel coordinates (aka parallel axes) chart.
@homepage index.html
@demo demo.html
-->
<dom-module id="px-vis-parallel-coordinates">
  <link rel="import" type="css" href="css/px-vis-parallel-coordinates.css"/>
  <template>
    <px-vis-multi-scale
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      dimensions="[[dimensions]]"
      chart-data="[[chartData]]"
      complete-series-config="[[completeSeriesConfig]]"
      chart-extents="[[chartExtents]]"
      x="{{x}}"
      y="{{y}}"
      current-domain-x="{{currentDomainX}}"
      current-domain-y="{{currentDomainY}}">
    </px-vis-multi-scale>
    <px-vis-svg-canvas
      canvas-context="{{canvasContext}}"
      svg="{{svg}}"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]">
    </px-vis-svg-canvas>
    <px-vis-line
      id="line"
      render-to-canvas
      gradient-line
      canvas-context="[[canvasContext]]"
      svg="[[svg]]"
      parallel-coordinates
      multi-path
      series-id="[[seriesKey]]"
      category-key="[[categoryKey]]"
      categories="[[categories]]"
      chart-data="[[chartData]]"
      complete-series-config="[[completeSeriesConfig]]"
      x="[[x]]"
      y="[[y]]"
      current-domain-x="[[currentDomainX]]"
      current-domain-y="[[currentDomainY]]"
      muted-series="[[mutedSeries]]">
    </px-vis-line>
    <px-vis-multi-axis
      svg="[[svg]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      title-location='[[titleLocation]]'
      x="[[x]]"
      y="[[y]]"
      current-domain-x="[[currentDomainX]]"
      current-domain-y="[[currentDomainY]]"
      complete-series-config="{{completeSeriesConfig}}"
      series-key="[[seriesKey]]"
      chart-data="[[chartData]]"
      dimensions="[[dimensions]]"
      muted-series="{{mutedSeries}}"
      redraw-series="true"
      redraw-elems="[[_lineRedrawFun()]]"
      stroke-width="2"
      match-ticks="[[matchTicks]]"
      grid-ticks="{{gridTicks}}"
      grid-axis="{{gridAxis}}"
      common-axis="[[commonAxis]]"
      outer-tick-size="6">
    </px-vis-multi-axis>
    <template is="dom-if" if="[[matchTicks]]">
      <px-vis-gridlines
        svg="[[_calcGridSvg(svg,x,dimensions,currentDomainX)]]"
        tick-values="[[gridTicks]]"
        axis="[[gridAxis]]"
        margin="[[margin]]"
        length="[[_calcGridWidth(width,x,dimensions,currentDomainX)]]"
        orientation="left"
        current-domain="[[currentDomainY]]">
      </px-vis-gridlines>
    </template>
  </template>
</dom-module>

<script>
  Polymer({

    is: 'px-vis-parallel-coordinates',

    behaviors: [
      PxVisBehavior.sizing,
      PxVisBehaviorD3.svg,
      PxVisBehaviorD3.canvas,
      PxVisBehaviorD3.axes,
      PxVisBehaviorD3.axis,
      PxVisBehavior.dataset,
      PxVisBehavior.dimensions,
      PxVisBehavior.commonMethods,
      PxVisBehavior.chartExtents,
      PxVisBehavior.completeSeriesConfig,
      PxVisBehaviorD3.axisConfig,
      PxVisBehavior.mutedSeries,
      PxVisBehaviorD3.dynamicRedraw,
      PxVisBehavior.categories,
      PxVisBehavior.commonAxis,
      commonColors
    ],

    /**
     * Properties block, expose attribute values to the DOM via 'notify'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * An optional dev set array to specify which dimensions to plot
       *
       */
      axes: {
        type: Array,
        notify: true,
        value: function(){ return []; } //must!!!! have default value
      },
      /**
       * A dev set array of which keys in the chart data are not dimension axes. At a minimum, it must include the series-key. Required if axes is not specified.
       *
       */
      skipKeys: {
        type: Object,
        notify: true,
        value: function() { return {}; }
      },
      /**
       * A required dev set string which defines which data key to use for the series lines
       *
       */
      seriesKey: {
        type: String,
        notify: true
      },
      /**
       * A computed array of dimensions which the chart uses. If axes are specified, they are used for the dimensions. If not, it will use all the keys in the data except those specified in skipKeys
       *
       */
      dimensions: {
        type: Array,
        notify: true,
        computed: 'computeDimensions(chartData.*, axes, skipKeys.*)'
      },
      /**
       * A boolean to specify if the axis ticks should align or each have their own ranges
       *
       */
      matchTicks: {
        type: Boolean,
        value: false
      }
    },

    observers: [
      '_generateChartExtents(dimensions,chartData,commonAxis)',
      '_generateSeriesConfig(dimensions,chartData)',
      '_calcRenderTarget(chartData)',
      '_calcTitleLocation(svg,dimensions)'
    ],
    /**
     * At ready, set the margin and titleLocation objects
     *
     */
    created:function(){
      console.time('draw');
    },

    _calcTitleLocation: function(svg,dim){
      var textWidth = 0,
          _this = this;

      // append and remove the dimensions text so we can measure how long
      svg.selectAll('.dummyText')
        .data(dim)
        .enter()
        .append("text")
        .attr('class',"dummyText")
        .attr('font-size', this.labelTypeSize + 'px')
        .attr('font-style','GE Inspira Sans')
        .text(function(d) { return d})
        .each(function(d,i) {
          var w = this.getComputedTextLength();
          textWidth = Math.max(w,textWidth);
          this.remove(); // remove them just after displaying them
        });

      // add a bit for a margin between text labels
      textWidth += 10;
      //do we have enough space for the largest text label?
      if(this.width / dim.length < textWidth) {
        this.set('margin', { "top": 10, "right": 15, "left": 30, "bottom": textWidth});
        // vertical
        this.set('titleLocation',{
          "x":"3",
          "y":this.height - this.margin.bottom,
          "r":"-90",
          "anchor":"end"
        });
      } else {
        this.set('margin', { "top": 10, "right": 15, "left": 30, "bottom": (this.labelTypeSize + 8)});
        // horizontal
        this.set('titleLocation',{
          "x":"0",
          "y":this.height + 10 - this.margin.bottom,
          "r":"0",
          "anchor":"middle"
        });
        // angle
        // this.set('titleLocation',{
        //   "x":"0",
        //   "y":this.height - this.margin.bottom,
        //   "r":"-20",
        //   "anchor":"end"
        // });
      }
    },

    /**
     * FIXME: This should be called declaratively in renderToCanvas. But if we do this, first it triggers a draw rendering to svg and takes forever. Need to figure out where to put this and/or chain it so it works
     *
     */
    _calcRenderTarget: function(){
      this.set('renderToCanvas', this.chartData.length < 8000 );
    },
    /**
     * Method to compute the dimensions to use. If axes are specified, they are used for the dimensions. If not, it will use all the keys in the data except those specified in skipKeys
     *
     */
    computeDimensions: function(cD, axes, sK){
      if(this._doesObjHaveValues(this.chartData)){
        // if the dev specified which axes to use, set them as dimensions
        if(axes.length > 0) {
          return axes;
        }
        // else get them from the data.
        // add series and category key
        this.skipKeys[this.seriesKey] = true;
        if(this.categoryKey){
          this.skipKeys[this.categoryKey] = true;
        }
        // TODO what if the first object doesnt have all the dimensions?
        return Object.keys(this.chartData[0]).filter(function(d) {
          return typeof(this.skipKeys[d]) === 'undefined'
        }.bind(this));
      }
    },

    /**
     * Creates the series configuration file
     *
     */
      _generateSeriesConfig: function(dimensions){
      // TODO make work with multiple series
      var config = {};
      // add a seriesConfig with seriesKey as default
      config[this.seriesKey] = {
        "color": this._getColor(18),
        "name": this.seriesKey,
        "x": dimensions,
        "y": dimensions
      }
      // if categories are specified, use them
      if(typeof(this.categoryKey) !== 'undefined'){
        for(var i = 0; i < this.categories.length; i ++){
          config[this.categories[i]] = {
            "color": this._getColor(18 + i),
            "name": this.categories[i],
            "x": dimensions,
            "y": dimensions
          }
        }
      }

      this.set('completeSeriesConfig',config);
    },

    // * TODO These are in behavior chart. Should make it so we can import them from there */
    /**
     * Helper function to return the correct color for a particular index.
     **/
    _getColor: function(i){
      var l = this.seriesColorOrder.length,
          index = this._calcIndex(i,l);
      return this.dataVisColors[this.seriesColorOrder[ index ]];
    },
    /**
     * Helper function to calculate the index. When we run out of indcies, it loops back over valid indicies.
     **/
    _calcIndex: function(i,l){
      return i < l ? i : this._calcIndex(i - l,l);
    },
    /**
     * Creates the chartExtents for each dimension
     *
     */
    _generateChartExtents: function(dimensions){
      var ext = {
        "x": dimensions,
        "y": {}
      };

      // TODO Is there a smarter way of doing this?
      for(var i = 0; i < dimensions.length; i++){
        ext.y[dimensions[i]] = d3.extent(this.chartData, function(d) {
          return Number(d[dimensions[i]]);
        });
      }
      // if we want a common axis, find overall extents
      if(this.commonAxis){
        var maxMin = d3.extent(d3.merge(d3.values(ext.y)));
        for(var i = 0; i < dimensions.length; i++){
          // set each axis extent to max & min
          // TODO this is not the most efficient strategy, but certainly is the easiest, especially to keep it dynamic. Better would be to use only a single scale instead of calculating a scale multiple times.
          ext.y[dimensions[i]] = maxMin;
        }
      }

      // TODO we will need to support a common axis:
      /*
        if(common axis){
          if(dev set extents){
            use em!
          } else {
            cycle through our found extents
            pick out the largest min and max
          }
        }
      */
      this.set('chartExtents',ext);
    },

    /**
     * An array of the line elements.
     *
     */
    _lineRedrawFun: function(){
      return [this.$.line]
    },
    /**
     * Returns the width for the gridlines
     *
     */
    _calcGridWidth: function(w,x,dim){
      // overall width minus the inset for the axes
      return w - x(dim[0]) * 2;
    },
    /**
     * Retruns a g elem for the grid to draw to
     *
     */
    _calcGridSvg: function(svg,x,dim){
      // create a g and move it so it lines up with the first axis
      var g = svg.append('g')
        .attr("class", "grid")
        .attr("transform", "translate(" + x(dim[0]) + ",0)");
      return g;
    }
  });
</script>
